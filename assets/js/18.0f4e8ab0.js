(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{644:function(v,_,a){"use strict";a.r(_);var t=a(2),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"一、-路由概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、-路由概述"}},[v._v("#")]),v._v(" 一、       路由概述")]),v._v(" "),a("p",[v._v("异步式的数据传输接口，在IESB中称之为路由。数据传递，需要有数据源和数据目标，数据源和数据目标在ESB中称之为数据资源，常见的数据资源技术/协议如ActiveMQ、MQTT、Kafka、FTP、REDIS等，异步数据路由，只会将数据从数据源传递到数据目标，接口间的交互无法即时获取到响应，但是因为数据资源大多是支持大数据量、高并发的消息中间件，因此数据路由适用于大数据量、高并发的业务场景。")]),v._v(" "),a("p",[v._v("作为数据资源，必须具备生产数据和消费数据两项能力其中一个。在ESB中注册的数据资源，可以实现对数据资源的统一描述，ESB可以屏蔽不同数据资源在技术上的差异，由ESB来对数据进行消费和生产，并可配置特殊规则，对数据进行简单处理，降低开发工作量。数据传递的记录会被记录到日志中，可以很方便的在多系统参与的环境下快速定位数据和接口问题。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image002.jpg)")]),v._v(" "),a("h2",{attrs:{id:"二、-服务资源的注册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、-服务资源的注册"}},[v._v("#")]),v._v(" 二、       服务资源的注册")]),v._v(" "),a("p",[v._v("要赋予ESB从数据资源存取数据的能力，首先要对数据源（生产者）和数据目标（消费者）的数据资源在ESB中进行注册，在服务注册之前，需了解如下信息：")]),v._v(" "),a("p",[v._v("**1.\n**"),a("strong",[v._v("数据资源的类型：")])]),v._v(" "),a("p",[v._v("ActiveMQ、MQTT、FTP等")]),v._v(" "),a("p",[v._v("**2.\n**"),a("strong",[v._v("数据资源的描述信息")])]),v._v(" "),a("p",[v._v("简短、可读的唯一标识，用于在建立路由时予以区分")]),v._v(" "),a("p",[v._v("**3.\n** "),a("strong",[v._v("数据资源的连接/")]),v._v(" "),a("strong",[v._v("协议信息")])]),v._v(" "),a("p",[v._v("根据数据资源类型不同，可能有\nURL地址、用户名、密码、SSL证书等")]),v._v(" "),a("p",[v._v("**4.\n**"),a("strong",[v._v("数据资源的数据端点")])]),v._v(" "),a("p",[v._v("从数据资源中具体存取数据的位置，根据数据资源类型不同，可能有不同的称呼，如队列、主题、key、路径、SQL语句等")]),v._v(" "),a("p",[v._v("数据资源的注册都是在\n"),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("资源管理] – [")]),v._v(" **我的资源]**菜单下进行的。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image004.jpg)")]),v._v(" "),a("p",[a("strong",[v._v("目前的ESB****支持如下的技术与协议：")])]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image006.jpg)")]),v._v(" "),a("p",[a("strong",[v._v("ActiveMQ")]),v._v(" ：支持5.x版本，支持从队列、主题中消费、生产字符串数据。需要提供队列或主题名称。")]),v._v(" "),a("p",[a("strong",[v._v("MQTT")]),v._v(" ：支持从主题中消费、生产字符串数据。需要提供主题名称。")]),v._v(" "),a("p",[a("strong",[v._v("Kafka")]),v._v(" ：支持0.9以上版本，支持从kafka主题中消费、生产字符串数据。需要提供主题名称。")]),v._v(" "),a("p",[a("strong",[v._v("FTP")]),v._v(" ：支持从指定文件夹中的文件生产或消费字符串数据。需要提供文件夹路径；当数据源不带有文件名时，文件名将按照请求ID自动生成；当数据源和目标均为FTP且模式均为BINARY时，支持对文件的传递，BINARY模式不支持特殊规则和详细日志记录。")]),v._v(" "),a("p",[a("strong",[v._v("Redis")]),v._v(" ：支持从指定库的指定key中消费、生产字符串数据；key的类型可以是STRING/LIST/SET。需要提供库编号、key名称。")]),v._v(" "),a("p",[a("strong",[v._v("关系型数据库")]),v._v(" （支持Mysql/Oracle/SQLServer/PostgreSql/DB2）：支持通过SQL语句消费和生产数据。需要提供取数据SQL语句、存数据SQL语句和处理数据SQL语句，如非直接通过表存取数据，需要进行数据库开发视图、函数或存储过程。")]),v._v(" "),a("h2",{attrs:{id:"三、-路由的配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、-路由的配置"}},[v._v("#")]),v._v(" 三、       路由的配置")]),v._v(" "),a("p",[v._v("将数据从源，按照指定的规则传递到目标，为路由。在ESB中，数据源只有一个，数据目标可以是一个或多个，并可配置针对全局和针对单个数据目标的特殊规则：")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image008.jpg)")]),v._v(" "),a("p",[v._v("当前版本开箱即用的特殊规则如下：")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[v._v("消息提取")]),v._v(" "),a("th",[v._v("从JSON或XML数据中提取一部分数据组合成新的JSON或XML。")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("消息过滤")]),v._v(" "),a("td",[v._v("判断JSON或XML数据是否符合某个规则，如果符合则继续传递数据，否则不予传递。")])]),v._v(" "),a("tr",[a("td",[v._v("添加JMS头")]),v._v(" "),a("td",[v._v("添加固定的JMS头。")])])])]),v._v(" "),a("p",[v._v("其他特殊规则可以通过二次开发来实现。")]),v._v(" "),a("h2",{attrs:{id:"四、-服务概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、-服务概述"}},[v._v("#")]),v._v(" 四、       服务概述")]),v._v(" "),a("p",[v._v("同步式的数据交换接口，在ESB中称之为服务。常见的服务类型包括HTTP和WEBSERVICE。服务的接口，调用后立即就会得到响应，具有高实时性的特点，服务在部署后属于始终在线等待调用的状态，因此服务接口不适用于需要传递大量数据的业务接口。")]),v._v(" "),a("p",[v._v("服务接口属于开放式接口，在网络和接口设计允许的情况下，所有人均可对其进行调用，如不加以限制，极易受到攻击和恶意调用。通过将服务发布至ESB、由ESB对外提供服务接口，可以实现统一的权限校验和调用日志记录。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image010.jpg)")]),v._v(" "),a("h2",{attrs:{id:"五、-服务注册与版本管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、-服务注册与版本管理"}},[v._v("#")]),v._v(" 五、       服务注册与版本管理")]),v._v(" "),a("p",[v._v("要使用ESB来管理一个服务，首先要对服务进行注册，在服务注册之前，需了解如下信息：")]),v._v(" "),a("p",[v._v("ü  服务的类型：HTTP还是WEBSERVICE")]),v._v(" "),a("p",[v._v("ü  服务的名称：简短、可读的唯一标识，用于在部署时进行区分")]),v._v(" "),a("p",[v._v("ü  服务的URL地址：提供服务的真实接口地址")]),v._v(" "),a("p",[v._v("ü  服务的SSL证书及密码：可选")]),v._v(" "),a("p",[v._v("每个服务均可配置多个版本，每个版本可以拥有自己的URL地址、SSL证书，单个服务的不同接口，应当遵循向下兼容的原则，如果接口改动过大，应当注册一个新的服务来处理。不同版本之间快速切换，方便接口迭代升级。")]),v._v(" "),a("p",[v._v("服务的注册和版本管理都在ESB中  "),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("服务治理]")]),v._v(" -**\n[****服务列表]**功能中进行：")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image012.jpg)")]),v._v(" "),a("p",[v._v("服务在注册之后还不能立即工作，需要将其进行部署才能够对外提供服务。")]),v._v(" "),a("h2",{attrs:{id:"六、-生命周期管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、-生命周期管理"}},[v._v("#")]),v._v(" 六、       生命周期管理")]),v._v(" "),a("p",[v._v("服务和路由要开始提供服务，首先要将服务和路由打包成组件并安装至容器中运行。我们选用的容器遵循OSGi规范，在这个规范下，组件的生命周期如下：")]),v._v(" "),a("p",[v._v("![http://images.cnitblog.com/blog/489175/201310/10093556-27bc0ac0229c43018963014045513f67.png](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image014.jpg)")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("不同的组件可以独立进行热部署，\n\nESB省略了其中的中间过程（解析、启动中、停止中等），将安装至容器中的组件的生命周期管理简化为了如下三个状态：\n")])])]),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image016.jpg)")]),v._v(" "),a("p",[v._v("对于组件生命周期的管理也简化为如下四个：")]),v._v(" "),a("p",[v._v("ü   "),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("部署]")]),v._v(" ：将服务或路由组件安装至容器并启动，开始对外提供服务或路由数据")]),v._v(" "),a("p",[v._v("ü   "),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("卸载]")]),v._v(" ：将已安装或已启动的服务组件从容器中移除，停止对外提供服务或路由数据")]),v._v(" "),a("p",[v._v("ü   "),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("停止]")]),v._v(" ：将已启动的服务暂停对外提供服务或路由数据，状态变为已安装")]),v._v(" "),a("p",[v._v("ü   "),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("启动]")]),v._v(" ：将已安装的服务开始对外提供服务或路由数据，状态变为已启动")]),v._v(" "),a("p",[v._v("具体操作均在\n"),a("strong",[v._v("[")]),v._v(" **服务列表]**或  "),a("strong",[v._v("[")]),v._v(" **路由列表]**中  "),a("strong",[v._v("[")]),v._v(" **控制]**一列进行以上四种操作。")]),v._v(" "),a("p",[v._v("只有已安装并启动的路由组件才会开始监听数据源的数据变化并开始传递数据。")]),v._v(" "),a("p",[v._v("只有已安装并启动的服务组件才会对外提供服务，服务状态为已启动时，容器会对外提供一个接口，接口所使用的端口默认为1916，示例如下：")]),v._v(" "),a("p",[a("strong",[v._v("http://127.0.0.1:1916/")]),v._v(" "),a("strong",[v._v("Saopb7Xg")])]),v._v(" "),a("p",[v._v("上述URL中，蓝色部分为容器固定的地址，红色部分为8位随机码，这个随机码在服务信息注册时，就已确定，后期对服务组件的生命周期管理或版本切换操作均不会改变整个URL的调用地址。")]),v._v(" "),a("p",[v._v("注：在接口注册之后，以实际接口地址开头的URL均可以直接访问，无需重复注册接口，示例如下：")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[v._v("实际接口地址")]),v._v(" "),a("th",[v._v("ESB服务地址")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("http://127.0.0.1/api/")]),v._v(" "),a("td",[v._v("http://127.0.0.1:1916/Saopb7Xg/")])]),v._v(" "),a("tr",[a("td",[v._v("http://127.0.0.1/api/user/manage/")]),v._v(" "),a("td",[v._v("http://127.0.0.1:1916/Saopb7Xg/user/manage/")])]),v._v(" "),a("tr",[a("td",[v._v("http://127.0.0.1/api/v2/test/")]),v._v(" "),a("td",[v._v("http://127.0.0.1:1916/Saopb7Xg/v2/test/")])]),v._v(" "),a("tr",[a("td",[v._v("http://127.0.0.1/api2/")]),v._v(" "),a("td",[v._v("无法访问，需要重新注册")])])])]),v._v(" "),a("p",[v._v("这个接口在部署之后立即使用，直接使用得到的状态码为900，并会在浏览器中提示如下错误信息，：")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image018.jpg)")]),v._v(" "),a("p",[v._v("这是因为服务必须符合对应的安全配置才可以正常使用，其中服务密钥是必须提供的。")]),v._v(" "),a("h2",{attrs:{id:"七、-服务安全配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、-服务安全配置"}},[v._v("#")]),v._v(" 七、       服务安全配置")]),v._v(" "),a("p",[v._v("目前版本ESB提供的服务安全机制可以分为两类：基于密钥和基于IP。作用范围也可以分为两类：单个服务的安全规则和ESB级的安全规则。规则的类型也可以分为两类：记录不允许访问的黑名单和记录允许访问的白名单。对安全机制分类、作用范围分类和黑白名单分类进行排列组合，可以有八种安全策略：")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("strong",[v._v("服务级密钥白名单")])]),v._v(" "),a("th",[v._v("服务级IP白名单")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[a("em",[v._v("全局级密钥白名单")]),v._v("*")]),v._v(" "),a("td",[v._v("服务级IP黑名单")])]),v._v(" "),a("tr",[a("td",[v._v("服务级密钥黑名单")]),v._v(" "),a("td",[v._v("全局级IP白名单")])]),v._v(" "),a("tr",[a("td",[v._v("全局级密钥黑名单")]),v._v(" "),a("td",[v._v("全局级IP黑名单")])])])]),v._v(" "),a("p",[v._v("其中，我们设定服务级密钥白名单为强制校验规则，所有服务接口必须配置密钥才允许访问，服务及密钥白名单，即服务密钥。服务密钥可以在\n"),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("服务安全]")]),v._v(" – **[****服务密钥]**功能中进行管理，用户可对自己可用的服务添加多个密钥、并可按照自身需求设置密钥过期时间，在密钥到期前，还可对密钥进行延期。")]),v._v(" "),a("p",[v._v("服务密钥是一个32位的随机代码，如0399babb02cf4af2afb3048e774e1ddc，服务密钥在设置之后，在调用对应接口时将密钥添加进去即可，添加的方法有三种：")]),v._v(" "),a("p",[v._v("将服务密钥添加至HTTP请求HEADER中，名为iesb_api_key（小写）")]),v._v(" "),a("p",[v._v("将服务密钥添加至HTTP请求参数中，名为iesb_api_key，例如：")]),v._v(" "),a("p",[a("strong",[v._v("http://127.0.0.1:1916")]),v._v(" "),a("strong",[v._v("/Saopb7Xg?")]),v._v(" "),a("strong",[v._v("iesb_api_key=0399babb02cf4af2afb3048e774e1ddc")])]),v._v(" "),a("p",[v._v("直接将服务密钥添加至调用的URL中，例如：")]),v._v(" "),a("p",[a("strong",[v._v("http://127.0.0.1:1916")]),v._v(" "),a("strong",[v._v("/Saopb7Xg/")]),v._v(" "),a("strong",[v._v("0399babb02cf4af2afb3048e774e1ddc/")])]),v._v(" "),a("p",[v._v("注：此方法如需调用实际接口URL下的接口，也可直接添加，如：")]),v._v(" "),a("p",[v._v("http://127.0.0.1:1916/Saopb7Xg/0399babb02cf4af2afb3048e774e1ddc/user/manage/")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("同样可以调用http://127.0.0.1/api/user/manage/\n")])])]),a("p",[v._v("以上三种方法可能根据服务接口的类型具有不同的兼容性，如果某一种调用发生异常，可以使用其他方法重试。")]),v._v(" "),a("p",[v._v("因服务密钥白名单的管理颗粒度已经非常细且设置了强制校验的规则，因此无需再设置全局级的密钥白名单来进行控制。同样，密钥的黑名单也因为白名单的强制校验的颗粒度已经非常细，我们将密钥的黑名单管理变为对于用户的黑名单管理，配置后，对应的用户就无法对范围的服务进行订阅，该用户之前生成的密钥也会一并失效无法使用。用户黑名单可以在\n"),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("服务安全]")]),v._v(" – "),a("strong",[v._v("[")]),v._v(" **黑白名单] ** – **[****用户黑名单] **功能中进行管理。")]),v._v(" "),a("p",[v._v("除密钥黑白名单外，服务级和全局级的IP黑、白名单可以在  "),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("服务安全]")]),v._v(" – "),a("strong",[v._v("[")]),v._v(" **黑白名单] ** – **[IP****黑白名单] **功能中进行管理。注：IP的白名单不属于强制校验规则，当没有配置全局IP白名单或服务IP白名单时，代表所有IP均可以访问。")]),v._v(" "),a("h2",{attrs:{id:"八、-日志与监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、-日志与监控"}},[v._v("#")]),v._v(" 八、       日志与监控")]),v._v(" "),a("p",[v._v("任何访问ESB提供的接口的动作和任何从ESB路由中传递的数据都会被ESB跟踪并记录，如果当前配置的日志级别低于这次操作的日志级别，该日志将会被记录。目前ESB对于日志级别的划分如下：")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[v._v("DEBUG/调试")]),v._v(" "),a("th",[v._v("服务特有，Webservice接口请求WSDL、XSD等描述性、辅助性文件")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("INFO/正常")]),v._v(" "),a("td",[v._v("正常调用/传递")])]),v._v(" "),a("tr",[a("td",[v._v("WARN/警告")]),v._v(" "),a("td",[v._v("服务被各类安全配置即IP密钥黑白名单阻止的调用 路由因为特殊规则被拦截")])]),v._v(" "),a("tr",[a("td",[v._v("ERROR/错误")]),v._v(" "),a("td",[v._v("连接性错误、接口报错、内部错误、数据错误")])])])]),v._v(" "),a("p",[v._v("同时，ESB按照日志是否需要被当作条件进行查询，分为了两大类：")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[v._v("简要日志")]),v._v(" "),a("th",[v._v("调用时间、日志级别、调用耗时、请求IP、所使用的密钥等")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("详细日志")]),v._v(" "),a("td",[v._v("请求参数、请求消息头、响应结果、响应结果头、消息内容")])])])]),v._v(" "),a("p",[v._v("简要日志可以进行检索和统计，详细日志仅供在显示对应的简要日志时附带进行显示。简要日志和详细日志的记录级别可以分别在\n"),a("strong",[v._v("[")]),v._v("  **系统管理] ** – "),a("strong",[v._v("[")]),v._v(" **参数管理] ** – **[****日志参数管理]**功能中进行配置。日志由容器自动记录，生成后的日志可以在\n"),a("strong",[v._v("[")]),v._v(" "),a("strong",[v._v("日志管理]")]),v._v(" – **[****服务日志] **中进行查询，同级目录下还有  "),a("strong",[v._v("[")]),v._v(" **日志分析]**和  "),a("strong",[v._v("[")]),v._v(" **日志监控]**功能。")]),v._v(" "),a("p",[v._v("对服务和路由的监控主要分为两个层级，一方面对服务和路由运行状态的监控，即服务和路由在容器中的运行状态，包括组件状态、进程ID、最近10次调用/传递的数据等，这部分数据由容器和容器中运行的对应组件实时反馈给控制台。另一方面是对服务/路由调用日志的分析，主要是当前时间段内调用/调用的次数。对活动的服务，可以在 "),a("strong",[v._v("[")]),v._v("  **服务治理] ** – **[****服务监控] **功能中进行监控。对活动的路由，可以在 "),a("strong",[v._v("[")]),v._v("  **路由管理] ** – **[****路由监控] **功能中进行监控。")]),v._v(" "),a("h2",{attrs:{id:"九、-接口发布及调用实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、-接口发布及调用实现原理"}},[v._v("#")]),v._v(" 九、       接口发布及调用实现原理")]),v._v(" "),a("p",[v._v("一次服务的调用，需要有两方同时参与：服务接口的调用方（下称消费者）和服务接口的提供方（下称生产者）。一次调用主要分为两个部分：消费者向生产者发起请求、服务的生产者返回调用结果给消费者。")]),v._v(" "),a("p",[v._v("ESB的服务治理的核心功能即服务的权限控制和调用日志记录及监消费者发起请求时进行控制、日志需要在调用结果返回给消费者时进行记录，要实现这些功能，所有的调用就需要通过服务组件（下称组件）来完成，组件必须拥有双向的调用通路，即同时拥有服务的生产和消费的能力。因此在设计上，我们使用公用的Jetty模块赋予了组件对外提供一个全新的接口调用地址的能力；使用公用的HttpClient模块附于了组件调用实际服务接口的能力，将两者进行桥接之后，在中间加入控制和日志逻辑。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image020.jpg)")]),v._v(" "),a("p",[v._v("在接收到请求时，组件将会解析出服务密钥与调用发起方的IP及组件自身的ID一同提交给安全组件进行安全校验，安全组件将会根据给定的条件得出本次请求是否允许访问，如果不允许访问，则直接返回对应错误代码。如果允许访问则会通过调用代理调用实际接口，并接收实际接口返回的调用结果。接收到结果后，组件将会调用日志模块进行日志记录，并将该结果返回给服务的调用者。")]),v._v(" "),a("p",[v._v("在上述调用过程中，如果发现目标服务无法连接或连接超时，同样会返回错误代码给消费者。一次调用无论成功与否，均会记录日志，方便管理和开发人员进行分析。")]),v._v(" "),a("h2",{attrs:{id:"十、-数据路由实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、-数据路由实现原理"}},[v._v("#")]),v._v(" 十、       数据路由实现原理")]),v._v(" "),a("p",[v._v("ESB的数据路由的核心功能包括数据消费/生产代理，数据处理（特殊规则）和日志以及监控功能。要能够实现由ESB将数据从数据源取出来，传递到数据目标，ESB就必须首先具备从各个数据源和目标存取数据的能力，为此我们制作了支持多种数据源的代理模块。")]),v._v(" "),a("p",[v._v("根据数据源技术的不同，代理模块或监听、或定时查阅、或被动接受消息来检测数据源的数据变化，当有数据流入时，由路由组件对数据进行处理，判断数据是否能够继续执行，如果能够继续执行，则交由数据目标方的代理来插入数据。当数据目标方的代理完成数据插入之后，路由组件将记录路由日志。记录日志的过程与服务相同。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image022.jpg)")]),v._v(" "),a("h2",{attrs:{id:"十一、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、"}},[v._v("#")]),v._v(" 十一、")]),v._v(" "),a("p",[v._v("性能优化与高可用设计")]),v._v(" "),a("p",[v._v("因为ESB的核心业务只有权限控制和日志记录两方面，不涉及复杂的计算，因而不会在CPU和内存方面出现瓶颈。要提高每个容器节点的性能，核心目标是降低硬盘IO和网络IO。为此，我们使用LevelDB / Redis等高性能KV数据库存储安全规则。日志数据使用Snappy和Protobuf进行压缩并序列化，极大降低写入硬盘的数据的长度。日志并不直接进入数据库，而是首先写入高性能队列缓存，优先保证服务的调用。由后台线程定时批量写入数据库，降低与数据库服务器间的IO。日志数据按照需要查询和不需要查询进行分类，分为了简要日志与详细日志，两者分离存储，并独立记录调用次数来提高查询效率。")]),v._v(" "),a("p",[v._v("在高可用方面，首要目标是降低单点的故障率，为此我们在技术选型上使用了广泛使用、高可靠性的开源容器Karaf，和功能强大、性能优越的数据集成中间件Camel作为基础组件。在集群设计上，我们使用Hazelcast数据网格作为集群的基础组件，在Hazelcast的集群中，各个节点均可以获取完全相同的数据和功能，因此ESB的集群无需遵循特定的奇数容器或一主多从等规则，所有容器均可对外提供相同的服务，确保了横向扩展的便捷性。")]),v._v(" "),a("p",[a("strong",[v._v("服务集群")])]),v._v(" "),a("p",[v._v("服务的集群，因为采用了上述集群模型，集群中所有的容器群都能统一对外提供服务。因此值需要一个外部的工具如BLB/NGINX来进行反向代理，即可实现负载均衡、故障转移。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image024.jpg)")]),v._v(" "),a("p",[a("strong",[v._v("路由集群")])]),v._v(" "),a("p",[v._v("服务的集群不能与服务一样，让所有容器都启动同一个路由，如果这样的话，遇到主题这类可以一对多的数据源，集群中有多少个容器，就会产生多少条重复数据。为此我们为路由的集群设计了一套特有的集群方案：安装路由时，将路由安装至集群中的所有容器，但是只有一个节点启动某个路由。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image026.jpg)")]),v._v(" "),a("p",[v._v("多个路由会均匀的部署在集群中的各个容器中，由多个容器共同承担压力。当某个容器宕机后，因为其他容器已经安装了完整的路由，只需要将其启动起来进行接管。从容器集群检测到单个容器断开到重新分配路由接管，只需要不到1秒时间，加上容器群自身设定的断开判定的超时时间，整个故障恢复会在5秒之内完成。")]),v._v(" "),a("p",[v._v("![](file:///C:\\Users\\YANGJI~1\\AppData\\Local\\Temp\\msohtmlclip1\\01\\clip_image028.jpg)")]),v._v(" "),a("h2",{attrs:{id:"附录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附录"}},[v._v("#")]),v._v(" 附录")]),v._v(" "),a("h3",{attrs:{id:"esb服务错误代码约定及报错顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#esb服务错误代码约定及报错顺序"}},[v._v("#")]),v._v(" ESB服务错误代码约定及报错顺序")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("ESB服务在因为各种原因无法调用时，均会返回对应的错误代码给调用者，错误代码即HTTP状态码，我们在HTTP规范下的1xx~5xx之外增加了9xx的状态码，供调用者将ESB报的错误代码与实际接口给的HTTP状态码予以区分。\n\nESB的错误代码如下：\n")])])]),a("table",[a("thead",[a("tr",[a("th",[v._v("900")]),v._v(" "),a("th",[v._v("未找到密钥。服务器在接受请求时，未能解析出提供的密钥。")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("901")]),v._v(" "),a("td",[v._v("密钥未经授权。提供的密钥不正确或密钥未被服务接受，请确认该密钥是当前服务的密钥。")])]),v._v(" "),a("tr",[a("td",[v._v("910")]),v._v(" "),a("td",[v._v("全局IP黑名单。当前请求源IP在全局IP黑名单中因而无法访问。")])]),v._v(" "),a("tr",[a("td",[v._v("911")]),v._v(" "),a("td",[v._v("服务IP黑名单。当前请求源IP在当前服务的IP黑名单中因而无法访问。")])]),v._v(" "),a("tr",[a("td",[v._v("912")]),v._v(" "),a("td",[v._v("密钥黑名单。当前请求所使用的密钥在当前全局密钥黑名单中因而无法访问。")])]),v._v(" "),a("tr",[a("td",[v._v("913")]),v._v(" "),a("td",[v._v("密钥黑名单。当前请求所使用的密钥在当前服务的密钥黑名单中因而无法访问。")])]),v._v(" "),a("tr",[a("td",[v._v("914")]),v._v(" "),a("td",[v._v("全局IP白名单。当前请求源IP不在全局IP白名单中因而无法访问。")])]),v._v(" "),a("tr",[a("td",[v._v("915")]),v._v(" "),a("td",[v._v("服务IP白名单。当前请求源IP不在服务IP白名单中因而无法访问。")])]),v._v(" "),a("tr",[a("td",[v._v("920")]),v._v(" "),a("td",[v._v("服务连接问题。当前服务出现连接、配置等错误导致无法访问。")])])])]),v._v(" "),a("p",[v._v("ESB的报错顺序也遵循上表中的顺序，当有请求时，将按照上表进行检查，发现错误即报错，当有多个原因导致无法访问的情况下，只返回第一个错误代码。")]),v._v(" "),a("h3",{attrs:{id:"调用示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用示例"}},[v._v("#")]),v._v(" 调用示例")]),v._v(" "),a("p",[v._v("假设获取到的服务密钥为1234567890abcdef1234567890abcdef")]),v._v(" "),a("p",[v._v("服务的调用地址为http://10.10.10.100:1916/abcdefgh")]),v._v(" "),a("p",[a("strong",[v._v("Http****调用")])]),v._v(" "),a("p",[v._v("jQuery调用示例：")]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">$.getJSON(</span>')]),v._v('"http://10.10.10.100:1916/abcdefgh"'),a("code",[v._v('<span lang="EN-US">,{<o:p></o:p></span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">iesb_api_key: </span>')]),v._v('"1234567890abcdef1234567890abcdef"')]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">}, </span>')]),v._v("function "),a("code",[v._v('<span lang="EN-US">(data){ </span>')])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v('alert`<span lang="EN-US">(data); </span>`\n')])])]),a("p",[a("code",[v._v('<span lang="EN-US">});</span>')])]),v._v(" "),a("p",[a("strong",[v._v("Webservice****调用")])]),v._v(" "),a("p",[v._v("CXF调用示例：")]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">JaxWsProxyFactoryBean factoryBean = </span>')]),v._v("new "),a("code",[v._v('<span lang="EN-US"> JaxWsProxyFactoryBean(); </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">factoryBean.setAddress(</span>')]),v._v('"http://10.10.10.100:1916/abcdefgh?iesb_api_key=1234567890abcdef1234567890abcdef"'),a("code",[v._v('<span lang="EN-US">); </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">factoryBean.setServiceClass(IHelloWorld.</span>')]),v._v("class "),a("code",[v._v('<span lang="EN-US">); </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">Object obj = factoryBean.create();</span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">IHelloWorld hw = (IHelloWorld) obj;</span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">hw.helloworld(</span>')]),v._v('"1"'),a("code",[v._v('<span lang="EN-US">);</span>')])]),v._v(" "),a("p",[v._v("原生JAX-WS调用示例：")]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">URL wsdlURL = new URL(</span>')]),v._v('"http://10.10.10.100:1916/1234567890abcdef1234567890abcdef?wsdl"'),a("code",[v._v('<span lang="EN-US">); </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">QName SERVICE_NAME = </span>')]),v._v("new "),a("code",[v._v('<span lang="EN-US"> QName(</span>')]),v._v('"http://demo.com/"'),a("code",[v._v('<span lang="EN-US">, </span>')]),v._v('"HelloWorld '),a("code",[v._v('<span lang="EN-US">"); </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">Service service = Service.create(wsdlURL, </span>')]),v._v('"HelloWorld"'),a("code",[v._v('<span lang="EN-US">); </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US">IHelloWorld client = service.getPort(IHelloWorld.class);<o:p></o:p></span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US"><br clear="all"/> </span>')])]),v._v(" "),a("p",[a("code",[v._v('<span lang="EN-US"><o:p> </o:p></span>')])]),v._v(" "),a("h3",{attrs:{id:"所用技术简单介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所用技术简单介绍"}},[v._v("#")]),v._v(" 所用技术简单介绍")]),v._v(" "),a("p",[a("strong",[v._v("Apache\nKaraf")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("Apache\n")])])]),a("p",[v._v("Karaf是一个基于OSGi的运行环境，它提供了一个轻量级的OSGi容器，可以用于部署各种组件与应用程序。Karaf提供了很多特性用于帮助开发者和用户更加灵活的部署应用，例如：热部署，动态配置，几种日志处理系统，本地系统集成，可编程扩展控制台，ssh远程访问，内置安装认证机制等等。同时Karaf作为一款成熟而且优秀的OSGi运行环境以及容器已经被诸多Apache项目作为基础容器，例如：Apache Geronimo， Apache ServiceMix，Fuse ESB，由此可见Karaf在性能、功能和稳定性上表现都相当不错。")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("ESB使用Karaf作为基础容器，提供基础组件运行容器、生命周期管理、模块化管理。\n")])])]),a("p",[a("strong",[v._v("Apache\nCamel")])]),v._v(" "),a("p",[v._v("Apache Camel是Apache基金会下的一个开源项目,它是一个基于规则路由和中介引擎，提供企业集成模式的Java对象的实现，通过应用程序接口（或称为陈述式的Java领域特定语言（DSL））来配置路由和中介的规则。领域特定语言意味着Apache Camel支持你在的集成开发工具中使用平常的，类型安全的，可自动补全的Java代码来编写路由规则，而不需要大量的XML配置文件。同时，也支持在Spring中使用XML配置定义路由和中介规则。")]),v._v(" "),a("p",[v._v("ESB使用了Camel提供服务组件最基本的消费和生产的功能。")]),v._v(" "),a("p",[a("strong",[v._v("Hazelcast")])]),v._v(" "),a("p",[v._v("Hazelcast作为一个高度可扩展的数据分发和集群平台，提供了高效的、可扩展的分布式数据存储、数据缓存。Hazelcast是开源的，在分布式技术方面，Hazelcast提供了十分友好的接口供开发者选择，如Map，Queue，ExecutorService, Lock和Jcache。")]),v._v(" "),a("p",[v._v("Hazelcast的稳定性很高，分布式应用可以使用Hazelcast进行存储数据、同步数据、发布订阅消息等。Hazelcast是基于Java开发的，其客户端有Java, C/C++, .NET以及REST。Hazelcast同时也支持memcache协议。")]),v._v(" "),a("p",[v._v("Hazelcast附带的Map和Queue用作集群模式下的规则存储和日志缓存，并且使用了Hazelcast的集群作为基础集群组件。")]),v._v(" "),a("p",[a("strong",[v._v("LevelDB")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("LevelDB是一个google实现的非常高效的kv数据库。LevelDB 是单进程的服务，性能非常之高，在一台4核Q6600的CPU机器上，每秒钟写数据超过40w，而随机读的性能每秒钟超过10w。\n\nLevelDB的写入性能极高，读取性能可观，因此被用作单机模式下的日志缓存和规则存储等方面。\n")])])]),a("p",[a("strong",[v._v("Protobuf")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("Protobuf是google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换都快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。\n\nProtobuf拥有序列数据字节短、效率高的特点，因此被选做日志存储的基础数据格式。\n")])])]),a("p",[a("strong",[v._v("Snappy")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("Snappy\n")])])]),a("p",[v._v("是一个用来压缩和解压缩的开发包。其目标不是最大限度压缩或者兼容其他压缩格式，而是旨在提供高速压缩速度和合理的压缩率。Snappy 比 zlib 更快，但文件相对要大 20% 到 100%。在 64位模式的 Core i7 处理器上，可达每秒 250~500兆的压缩速度。")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("Snappy的执行速度极快，用作对详细日志的文本进行压缩，降低硬盘和网络IO。\n")])])]),a("p",[a("strong",[v._v("Redis")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。\n\n作为一个外部的kv数据库，Redis可以同样作为日志缓存和规则存储的组件使用。\n")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);