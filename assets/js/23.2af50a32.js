(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{649:function(e,t,n){"use strict";n.r(t);var v=n(2),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("系统功能模块设计")]),e._v(" "),n("p",[e._v("l\n数据爬取")]),e._v(" "),n("p",[e._v("首先获取到最新的内部和外部网络安全法律条文，这个获取方式使用python开发爬虫小程序爬取最新的内部和外部网络安全法律条文，爬取成功以后，保存为txt文件。如图：")]),e._v(" "),n("p",[e._v("l\n数据格式化")]),e._v(" "),n("p",[e._v("一开始获取到的网络安全法律条文数据里面的结构是先列出总体的目录，再是每个章节以及每个章节里面有哪些条文，这种数据结构不是我们期望的数据结构。因为我们想要实现根据关键字检索出包含关键字的所有发条，以及检索出来的发条来源与哪些章节，原始的文本内容数据结构不方便实现这个需求，所以我们设计了如下图的数据结构：")]),e._v(" "),n("p",[e._v("使用“|”字符作为分割符，“|”字符前面的数据为法条来源的章节，“|”字符后面的数据为每条法条的内容。这样程序代码里通过“|”字符就可以很方便地分割出每条法条以及每条法条来源的章节，这为后面的检索功能实现打下了基础。")]),e._v(" "),n("p",[e._v("数据结构设计好了以后，我们使用python脚本读取之前保存的《最新内部网络安全法律条文.txt》和《最新内部网络安全法律条文.txt》文件，读取每一行文本记录，使用正则表达式匹配读取到的内容，当匹配到读取的内容含有“章”这个关键字时，就知道这是法条的章节，则把章节的内容写入到格式化文本文件。例如当读取到的一整行内容为“第一章 总   则”时，则将“第一章  总    则”写入到格式化文本文件，因为后面的内容都是“第一章  总    则”对应的法条，所以程序继续在获取到每行法条内容时，都会先在格式化文本文件中先写入章节内容并且后面紧跟着写入分割符“|”，再把获取到的每行法条内容写入到分割符“|”后面，这样就把每个章节、每个章节对应的法条通过分割符“|”结构化保存在格式化文件里，最后输出《最新内部网络安全法律条文-格式化.txt》和《最新内部网络安全法律条文-格式化.txt》文件。")]),e._v(" "),n("p",[e._v("l\n建立索引")]),e._v(" "),n("p",[e._v("我们使用python的全文检索库whoosh实现全文检索的功能。通过pip  install whoosh命令就可以安装whoosh库，安装好以后，先定义Schema对象，如下图：")]),e._v(" "),n("p",[e._v("schema =\nSchema(title=TEXT(stored=True, analyzer=ChineseAnalyzer()),")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("content=TEXT(stored=True,\n")])])]),n("p",[e._v("analyzer=ChineseAnalyzer())")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(")\n")])])]),n("p",[e._v("Schema对象定义了索引的所有域。一个域就是索引对象里面每个文档的一个信息。")]),e._v(" "),n("p",[e._v("例如上面这个Schema对象有两个域，分别是“title”和“content”，表示使用定义了“title”和“content”域的Schema对象在生成索引文档时，每个索引文档都有的“title”和“content”两个字段的内容，并且这两个字段的内容都能够被索引。")]),e._v(" "),n("p",[e._v("“stored=True”表示得到在生成索引文档时，将索引之后的结果保存在磁盘。analyzer=ChineseAnalyzer()，这句代码表示使用python的中文分词库jieba作为中文分词，因为我们要检索的文本内容是中文，所以要对中文进行分词，中文文本通过分词后会获得单个的词语，这样才能对每个词语和每个文档做倒排索引。python的中文分词库jieba是一个优秀的中文分词库，中文分词效果非常好，这里我们选用jieba来做中文分词。")]),e._v(" "),n("p",[e._v("定义好Schema对象后，使用python脚本读取《最新内部网络安全法律条文-格式化.txt》和《最新内部网络安全法律条文-格式化.txt》文件，通过分割符“|”分割出章节和每条法条内容，将章节的内容映射到“title”域，将每条法条映射到“content”\n域，最后就把所有格式化的法条内容都生成了索引文档，并保存在本地磁盘上。")]),e._v(" "),n("p",[e._v("当需要使用关键字检索时，只需要使用whoosh的检索器对象Searcher来检索就可以检索到相应的结果，例如我们使用“犯罪”作为关键字检索，得到如图所示结果：")]),e._v(" "),n("p",[e._v("l\nPyqt5 UI界面开发")]),e._v(" "),n("p",[e._v("我们使用使用QT designer.exe画Pyqt5\nUI界面，画好的界面如图所示：")]),e._v(" "),n("p",[e._v("画好UI界面后，通过复制QT designer.exe生成的python代码，就可以快速的实现一个UI界面程序，复制代码操作过程如图所示：")]),e._v(" "),n("p",[e._v("我们使用pyqt5的QLineEdit部件让用户输入检索关键字，使用QPushButton作为搜索按钮，搜索按钮绑定具体的搜索实现方法：search（）；使用两个QTextEdit富文本部件展现内新法条检索结果和外新法条检索结果。")]),e._v(" "),n("p",[e._v("l\n检索功能实现")]),e._v(" "),n("p",[e._v("要关键字进行检索，首先要获取到客户输入的关键字，然后才能进一步做检索。当用户输入关键字点击搜索按钮后，搜索按钮绑定的search（）就会被调用。在search（）里实现了具体的搜索功能。")]),e._v(" "),n("p",[e._v('我们使用pyqt5的QLineEdit部件的text()方法获取用户输入的内容。为了保证程序的健壮性，调用QLineEdit部件的text()方法后，我们对返回结果做了非空判断。#如果用户没有输入任何内容就直接点搜索按钮，则提示给用户"请输入您要查找的内容后，再点击搜索。"的提示信息，因为没有关键字点搜索没有意义。')]),e._v(" "),n("p",[e._v("确认检索关键字不为空字符串后，我们分别创建外新法条和内新法条的文本搜索器对象，代码如下：")]),e._v(" "),n("p",[e._v("with self.ix.searcher() as\nsearcher,self.ix_neixin .searcher() as searcher_neixin:")]),e._v(" "),n("p",[e._v("其中self.ix为之前生成的索引对象。")]),e._v(" "),n("p",[e._v("再分别调用外新法条和内新法条搜索器的find（），使用关键字在外新法条和内新法条索引库中检索出现包含关键字的记录，如果有多条检索结果，会返回一个list集合，代码如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("results =\n")])])]),n("p",[e._v('searcher.find("content", searchText)')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("results_neixin =\n")])])]),n("p",[e._v('searcher_neixin.find("content", searchText)')]),e._v(" "),n("p",[e._v("获取到检索结果内容集合后，分别调用内新法条检索结果和外新法条检索结果的QTextEdit富文本部件的append()方法，将检索结果内容加载到QTextEdit富文本部件中。这时候，界面已经能够展现检索结果了。但是检索出来的结果很多，我们还想对关键字进行高亮醒目显示，这样方便验证检索结果的正确性。")]),e._v(" "),n("p",[e._v("l\n关键字高亮显示")]),e._v(" "),n("p",[e._v("对关键字进行高亮显示，主要使用到了pyqt5的QTextEdit部件的游标对象：QTextCursor，该对象可以在文本的任意位置对用户输入的内容操作修改。具体高亮实现过程如下：")]),e._v(" "),n("p",[e._v("首先获取关键字在检索结果集合的文本内容中的位置。比如，检索集合的文本内容是“第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。”，检索关键字是价值观。那么“价值观”这句话中位于第33个位置（下标从0开始），则游标对象QTextCursor会移动到关键字所在位置也就是第33个位置，然后根据关键字“价值观”的长度往后移动相应的步数，也就是往后再移动3个单位，这样游标对象QTextCursor就把关键字“价值观”选中了，就可以对关键字进行高亮设置，设置后，在程序界面就高亮展示了。")]),e._v(" "),n("p",[n("a",{attrs:{href:""}},[e._v("3.3 ")]),e._v("系统界面设计与实现")]),e._v(" "),n("p",[e._v("我们使用使用QT\ndesigner.exe画Pyqt5 UI界面，画好的界面如图所示：")]),e._v(" "),n("p",[e._v("画好UI界面后，通过复制QT designer.exe生成的python代码，就可以快速的实现一个UI界面程序，复制代码操作过程如图所示：")]),e._v(" "),n("p",[e._v("我们使用pyqt5的QLineEdit部件让用户输入检索关键字，使用QPushButton作为搜索按钮，搜索按钮绑定具体的搜索实现方法：search（）；使用两个QTextEdit富文本部件展现内新法条检索结果和外新法条检索结果。")])])}),[],!1,null,null,null);t.default=_.exports}}]);